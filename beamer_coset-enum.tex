\documentclass[aspectratio=169, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}
\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}
\usepackage{hyperref}
\usepackage{eufrak}
\usepackage{tikz-cd}
\usepackage{tcolorbox}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem
	\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}

\setbeamercolor{background canvas}{bg=white}
\usepackage{multicol}
\usepackage{chronology}
%%%%%%%%%%%%%%%%%%%%% ENUMERAR CON COSAS QUE NO SEAN SOLO NÚMEROS %%%%%%%%%%
%\usepackage[shortlabels]{enumitem}
%\setlist[enumerate]{font=\bfseries}

\usepackage{booktabs}
%\usepackage[scale=2]{ccicons}

\usepackage{clrscode3e}

%%%%%%%% ALGORITMOS %%%%%%%%
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}  % "noend" es para no mostrar los endfor, endif

% PARA PODER HACER EL FLOW CHART
\usetikzlibrary{shapes,arrows}

\usepackage{pgfplots}
%\usepgfplotslibrary{dateplot}
\colorlet{verde}{green!50!black}
\definecolor{amber}{rgb}{1.0, 0.49, 0.0}
\setbeamercolor{progress bar}{fg=amber,bg=alerted text.fg!50!black!10}

\makeatletter
\setlength{\metropolis@titleseparator@linewidth}{2pt}
\setlength{\metropolis@progressonsectionpage@linewidth}{2pt}
\setlength{\metropolis@progressinheadfoot@linewidth}{2pt}
\makeatother

\definecolor{ultramarine}{RGB}{81, 131, 232} 
\setbeamercolor{frametitle}{bg= ultramarine}

\usepackage{framed}
\definecolor{shadecolor}{gray}{0.9}

\renewcommand\qedsymbol{\textcolor{orange}{$\blacksquare$}}

\usepackage[font={footnotesize}]{caption}

% Para agregar columnas.
\usepackage{graphicx}
\usepackage{adjustbox}
\setbeamercovered{invisible}


\usepackage{xspace}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}
\newcommand{\fg}{finitamente generado }
\newcommand{\fp}{finitamente presentado }
\newcommand{\rep}{\textsc{rep}}
\newcommand{\coin}{\textsc{coincidencia}}
\newcommand{\mer}{\textsc{merge}}
\newcommand{\edeff}{\textsc{estáDefinido}}
\newcommand{\scan}{\textsc{scan}}
\newcommand{\definir}{\textsc{definir}}
\newcommand{\scanfill}{\textsc{scanandfill}}
\newcommand{\ded}{\textsc{deducir}}
\newcommand{\recorrer}{\textsc{recorrer}}
\newcommand{\In}{[1 \dots n]}
\newcommand{\ol}{\overline}
\newcommand{\Co}{{\cal{C}}}



\title{Algoritmo de enumeración de cosets.}
\subtitle{Seminario de topología - UBA.}
\date{12 de octubre de 2022.}
\author{Leopoldo Lerena}
\institute{Universidad de Buenos Aires}
% \titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\begin{document}
\maketitle

\begin{frame}[fragile]{Introducción.}


Muchas preguntas naturales que nos podemos hacer conociendo una presentación de algún grupo tales cómo:

\begin{itemize}
	\item ¿Cuál es su orden?
	\pause
	\item ¿Cuál es 	el índice de un subgrupo?
	\pause
	\item ¿Cómo es su grafo de Cayley?
	\pause
\end{itemize}

Vamos a poder responderlas hoy usando un algoritmo de enumeración de cosets.
\end{frame}

\begin{frame}[fragile]{Algoritmos en teoría de grupos.}
	Tengamos en cuenta que muchas preguntas elementales de la teoría de grupos tales como:
	\begin{itemize}
		\item Dada una palabra en los generadores, ¿es igual a la identidad del grupo?
		\pause
		\item ¿Es un grupo finito?
		\pause
		\item Más aún, ¿es el grupo trivial?
	\end{itemize}
	\pause
	No son \textit{decidibles}. 
	No existe un algoritmo que nos pueda responder estas preguntas dada una presentación finita arbitraria.
	\medskip
	
	\pause
	
	
	Nos tenemos que conformar con que existan procedimientos que son \textit{semidecidibles}. 
\end{frame}

\begin{frame}[fragile]{Descripción del algoritmo.}
	El procedimiento de enumeración de cosets requiere los siguientes parámetros para la entrada:
	\begin{itemize}
		\item Un grupo $G$ \fp;
		\pause
		\item Una presentación finita de este grupo $\langle X | R \rangle$.
			Donde $X = \{ x_1, \dots, x_n \}$ y $R = \{ r_1, \dots, r_m \}$ son conjuntos finitos;
 		\pause
		\item Un subgrupo $H \le G$  \fg con generadores $Y$ visto como palabras en $A = X \cup X^{-1}$.
	\end{itemize}
	\pause
	\medskip
	
	En el caso que el procedimiento termine nos va a devolver lo siguiente:
	\pause
	\begin{itemize}
		\item El índice del subgrupo $H$ en $G$.
		\pause
		\item La representación de $G$ por permutaciones actuando a derecha por multiplicación sobre los cosets a derecha de $H$.
	\end{itemize}  
\end{frame}

%\begin{frame}[fragile]{Un poco de historia.}
%	El primer algoritmo de esta familia fue construido por Todd--Coxeter en el paper ""
%	\alert{Agregar imagen del paper}
%	con la idea de poder hacer manualmente este conteo de  
%\end{frame}

\begin{frame}[fragile]{Tabla de cosets.}
	Sea $G = \langle X | R \rangle$ un grupo \fp y sea $A = X \cup X^{-1}$ sus generadores y sus inversos.
	Sea $H$ subgrupo generado finitamente por $Y$ un conjunto de elementos de $A^*$.
	\pause
	\begin{alertblock}{Definición.}
		La tabla de cosets $\Co $ va a ser una tupla $(n, \tau, \chi)$ donde:
		\pause
		\begin{itemize}
			\item $n \in  \mathbb{N}$ es la cantidad de cosets que tenemos definidos, esto es el intervalo $\In$ va a representar a todos los cosets enumerados hasta el momento;
			\pause
			\item $\tau : \In \to A^*$ es una función que a cada coset $i$ le asigna una palabra en los generadores tal que $\tau(i)$ sea un representante de la clase de este coset.
			\pause
			\item $\chi: \In \times A \rightharpoonup \In$ una función parcial tal que si $\chi(i, x) = j$ esto lo interpretamos como que al coset $i$ al multiplicarlo por la letra $x$ vamos al coset $j$.
			\pause
			Notación: $i^x = j$.
			%		\pause
			%		\item $p: [1 \dots n] \to [1 \dots n]$ una función tal que $p(i) \le i$ para todo $i \in [1\dots n]$.
		\end{itemize}
		
		
		
	\end{alertblock}
	
	
\end{frame}

\begin{frame}[fragile]{Observaciones previas.}
	Algunas observaciones previas.
	\begin{itemize}
		\item El $1 \in \In$ lo reservamos para referirnos al coset trivial $H \in G/H$.
		Esto es $\tau (1) = 1$.
		
		\pause
		\item  Podemos extender la definición de $\chi: \In \times A^{*} \rightharpoonup \In$ de manera que tome palabras de la siguiente manera recursiva. 
		Dado $i \in \In, x \in A, w \in A^{*}$
		\[
		\chi(i,xw) = \chi (\chi(i,x), w)
		\]
		siempre y cuando esté definido.
		
		\pause
		
		\item Todo coset $Hg \in G/H$ es tal que $(Hg)r = 1$ para toda $r \in R$.
		
		\pause
		
		\item Similarmente tenemos que para todo $y \in Y$ vale que $Hy = H$.
	\end{itemize}
\end{frame}
\begin{frame}[fragile]{Escanear cosets.} 
	\begin{alertblock}{Definición.}
		Dada una tabla de cosets $\Co$ diremos que un \emph{coset $i \in \In$ escanea correctamente a una relación $r \in R$} si suceden estas dos cosas:
		\begin{itemize}
			\item El coset $i^r$ está definido.
			\item Vale que $i^r = i$.
		\end{itemize}
	\end{alertblock}
	
	\pause
	
	\begin{alertblock}{Definición.}
		Dada una tabla de cosets $\Co$ diremos que \emph{el coset $1 \in \In$ escanea correctamente al generador $y \in Y$} si suceden estas dos cosas:
		\begin{itemize}
			\item El coset $1^y$ está definido.
			\item Vale que $1^y = 1$.
		\end{itemize}
	\end{alertblock}
	
	

	\pause
	\medskip
	
	
	
	La tabla está \emph{completa} si $\chi:\In \times A \to \In$ está definida para todos los pares $(i, x) \in \In \times A$. 
\end{frame}

%\begin{frame}[fragile]{Propiedades de la tabla de cosets.}
%	La tabla de cosets vamos a querer que mantenga ciertas propiedades a medida que corramos el algoritmo, esto vendría a ser el invariante de representación.
%	\pause
%	
%	
%	
%	\begin{enumerate}
%		\item $1 \in \Omega$ y $1^{\tau(i)} = i$.
%		\pause
%		\item $i^x = j \iff j^{X} = i$
%		\pause
%		\item Si $i^x = j$ entonces tenemos que $H \tau(i) x = H \tau(j)$
%		\pause
%		\item Para todo $i \in \In$ tenemos que $1^{\tau(i)}$ está definido y $1^{\tau(i)} = i$.
%	\end{enumerate}
%\end{frame}

\begin{frame}[fragile]{Correctitud del algoritmo.}
	Nuestro objetivo es ver qué condiciones tiene que cumplir la tabla de cosets para garantizar que enumera correctamente a todos los cosets.
	
	\pause
	\begin{alertblock}{Proposición.}
		Si $\Co$ cumple que:
		\begin{itemize}
			\item  $i^x = j \iff j^{X} = i$.
			\item Todos los cosets $\In \in \Co$ escanean correctamente a todas las relaciones $r \in R$. 
		\end{itemize}
		entonces tenemos un morfismo de grupos 
		\[
			\varphi: G \to S(\In)
		\]
		dado por $\varphi(g) (i) = i^g$.
	\end{alertblock}
	\medskip
	\pause
	\textbf{Demostración}
	Lo tenemos definido sobre los generadores $A = X \cup X^{-1}$.
	\pause 
	Esto nos da un morfismo sobre el monoide libre $A^{*}$.
	\pause
	Usando la propiedad que $i^x = j \iff j^{X} = i$ lo podemos definir sobre el grupo libre $F(X)$.
	\pause
	Finalmente como todos los cosets enumerados escanean correctamente todas las relaciones tenemos que baja a un morfismo del grupo $G$. \qedsymbol
\end{frame}


\begin{frame}[fragile]{Correctitud del algoritmo.}
	Definamos la siguiente función del conjunto de cosets enumerados en los cosets.
	\[
	\ol \tau: \In \to G/H
	\]
	tal que $\ol \tau (i) = H \tau (i)$.
	\pause
	Veamos bajo qué condiciones nos queda una biyección. 
	En tal caso habremos enumerado correctamente a los cosets.
	\medskip
	\pause
	\begin{alertblock}{Proposición.}
		Si la tabla de cosets $\Co$ está completa, si $i^x = j$ entonces tenemos que $H \tau(i) x = H \tau(j)$ y para todo $i \in \In$ tenemos que $1^{\tau(i)}$ está definido y $1^{\tau(i)} = i$ entonces $\ol \tau$ resulta ser sobreyectiva.
	\end{alertblock}
	\pause
	
	\textbf{Demostración.}
	Dado $Hg \in G/H$ como la tabla está completa tenemos definido $i$ tal que $H\tau(i) = Hg$ usando que $g = x_1 \dots x_n$ en los generadores $A$. \qedsymbol
	
	\pause
	\begin{alertblock}{Proposición}
		Si la tabla de cosets $\Co$ es tal que el coset $1$ escanea correctamente a todo generador $y \in Y$ entonces $\ol \tau$ resulta ser inyectiva.
	\end{alertblock}
	\pause
	\textbf{Demostración.}
	Si $\ol \tau (i) = \ol \tau (j)$ entonces $H \tau (i) \tau (j)^{-1} = H$ \pause y acá usamos que escanea correctamente a todos los generadores de $H$. \qedsymbol
\end{frame}


\begin{frame}[fragile]{Correctitud del algoritmo.}
	En definitiva probamos el siguiente resultado sobre la tabla de cosets.
	\pause
	\begin{alertblock}{Teorema}
		Si valen las siguientes condiciones,
		\begin{itemize}
			\item Para todo $i \in \In$ tenemos que $1^{\tau(i)}$ está definido y $1^{\tau(i)} = i$;
			\item $i^x = j \iff j^{X} = i$;
			\item Si $i^x = j$ entonces tenemos que $H \tau(i) x = H \tau(j)$;
			\item La tabla de cosets está completa;
			\item 1 escanea correctamente para todo $y \in Y$;
			\item $i$ escanea correctamente para todo $r \in R$ y para todo $i \in \Omega$.
		\end{itemize}
		\pause
		entonces $[G:H] = n$ y para todo $g \in G$, $\varphi(x): \In \to \In$ definida por $\varphi(g)(i) = i^g$ es una permutación.
		A su vez la acción sobre los cosets enumerados coincide con la acción de $G$ sobre los cosets a derecha de $H$.
	\end{alertblock}
	\pause
	\medskip
\end{frame}

%\begin{frame}[fragile]{Demostración correctitud de enumeración de cosets.}
%	\textbf{Demostración}.  
%	
%			Se extiende a un morfismo de grupos por la \textbf{P2} y porque escanea todas las relaciones.	
%			\pause
%			% Lo definimos sobre el monoide libre en un pcpio y con la P2 lo tenemos sobre el grupo libre.
%			
%			\medskip
%			Definimos la función 
%			\[
%			\ol \tau: \Omega \to G/H
%			\]
%			tal que $\ol \tau (i) = H \tau (i)$.
%			\pause
%			Probemos que es una biyección.
%			\pause
%			\begin{itemize}
%				\item Sobreyectiva. Usamos que la tabla está completa y que vale \textbf{P4}.
%				\pause
%				\item Inyectiva. Si $\ol \tau (i) = \ol \tau (j)$ entonces $H \tau (i) \tau (j)^{-1} = H$ y acá usamos que escanea correctamente a todos los generadores de $H$.
%				\pause
%			\end{itemize}
%			Con esto concluimos que $[G:H] = |C| = |\Omega|$ y que la acción sobre $\Omega$ coincide con la acción sobre los cosets a derecha.	
%			\qedsymbol
%		
%\end{frame}


\begin{frame}[fragile]{Ejemplo (1/4)}
	\section{Ejemplo a mano del procedimiento.}
	Partamos del grupo \fp $G = \langle x, y | x^2, y^3, [x,y] \rangle$ tal que $G \simeq \Z / 2\Z \times \Z / 3\Z$.
	Notaremos $X = x^{-1}$ e $Y = y^{-1}$.
	\pause
	Tomemos como subgrupo $H = \langle x \rangle$.
	\pause
	El algoritmo va enumerando los cosets de $H$ en $G$ que por el teorema de estructura sabemos que son exactamente 3.
	\pause
	\medskip
	

	Empezamos asignando el número {1} al coset trivial correspondiente a $H$ en $G/H$.
	\pause 
	Como $x \in H$ entonces sabemos que $Hx = H$, denotaremos por $\textbf{1}^x = \textbf{1}$ a la multiplicación de $\textbf{1}$ por $x$.
	\pause
	Similarmente $\textbf{1}^{X} = \textbf{1}$.
	\pause
	Por otro lado denotemos con \textbf{2} al coset $\textbf{1}^y$ y \pause denotaremos por \textbf{3} al coset $\textbf{1}^{Y}$.
	\pause
	De esta manera $2^Y = 1$ \pause y por otro lado $3^y = 1$.
	

	\onslide<4->
	\begin{table}[]
		\begin{tabular}{|c | c | c | c | c |} 
			\hline
			Coset     & x          & X          & y          & Y          \\ 	\hline 
			\textbf{1} & \onslide<5-> \textbf{1} & \onslide<6-> \textbf{1} & \onslide<7-> \textbf{2} & \onslide<8-> \textbf{3}  \\   \hline 
			\onslide<7-> \textbf{2} &            &            &            &  \onslide<9-> \textbf{1}         \\ \hline 
			\onslide<8-> \textbf{3} &            &            &    \onslide<10-> \textbf{1}       &            \\ \hline
		\end{tabular}
	\end{table}
	

\end{frame}

\begin{frame}[fragile]{Ejemplo (2/4).}
% ¿Qué podemos hacer?

%\pause
%Queremos que valga esto mismo para los que estamos enumerando, esto es que $i^r = i$ para todo $i \in \{ 1,2,3 \}$ y toda $r \in \{  x^2, y^3, xyXY  \}$.

%Vamos a introducir un proceso que se llama \textit{escanear las relaciones}.

Veamos de escanear los cosets por las relaciones del grupo.
Por ejemplo tomemos $r = y^3$ y escaneamos a $\textbf{1}$.


\pause

Queremos garantizar que $1^{y^3} = 1$. 
\pause
\begin{columns}
	\begin{column}{0.6\textwidth}
		\begin{align*}
			&1^{yyy} = 1 \\
			\iff&	1^{yy}	= 1^{Y} \\ 
			\iff&	(1^y)^y = 3 \\ 
			\iff&	2^y = 3 
		\end{align*}
	\end{column}
	\begin{column}{0.4\textwidth}
		\onslide<4->
		\begin{table}[]
			\begin{tabular}{|l|l|l|l|l|}
				\hline
				Coset     & x          & X          & y          & Y          \\ \hline
				\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
				\textbf{2} &            &            &            &  \textbf{1}          \\ \hline
				\textbf{3} &            &            &     \textbf{1}       &            \\ \hline
			\end{tabular}
		\end{table}
	\end{column}
\end{columns}






%Tenemos que $\textbf{1}^y = \textbf{2}$ por como definimos al coset $\textbf{2}$. 
%Por otro lado tenemos que $\textbf{1}^{y^2} = \textbf{2}^y$ todavía no está definido.
%\pause
%
%
%Como $r^{-1} = 1$ visto como elemento en $G$ si escanemos ahora viendo esta relación tenemos que $\textbf{1}^{Y} = \textbf{3}$ porque así lo definimos y por otro lado que $\textbf{3}^{Y}$ no está definido.
\pause

\end{frame}

\begin{frame}[fragile]{Ejemplo (3/4)}
	De lo anterior podemos \textit{deducir} que $\textbf{2}^y = \textbf{3}$ y simultaneamente que $3^Y = 2$.
	
	\medskip
	\pause
	\begin{center}
		\begin{tikzcd}
		\textbf{1} \arrow[r, "y", bend left] & \textbf{2} \arrow[r, "y", dotted, bend left] & \textbf{3} \arrow[r, "y", bend left] & \textbf{1}
		\end{tikzcd}
	\end{center}
	\pause
	
	De esta manera nuestra tabla ahora tiene la siguiente pinta.
	

	
	
	\begin{table}[]
		\begin{tabular}{|l|l|l|l|l|}
			\hline
			Cosets     & x          & X          & y          & Y          \\ \hline \onslide<3->
			\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline \onslide<3->
			\textbf{2} &            &            & \onslide<4>\color{verde}\textbf{3} &     \onslide<3->\textbf{1}       \\ \hline \onslide<3->
			{\textbf{3}} &       \onslide<3->     &     \onslide<3->       & \onslide<3->  \textbf{1}         & \onslide<4>\color{verde}\textbf{2} \\ \hline 
		\end{tabular}
	\end{table}
	
	
\end{frame}

\begin{frame}[fragile]{Ejemplo (4/4)}
	Cuando escaneamos la relación $r=xyXY$ para los cosets \textbf{1} y \textbf{2} 
	llegamos a las siguientes deducciones 
	\pause
	\begin{center}
		\begin{tikzcd}
		\textbf{1} \arrow[r, "x", bend left] & \textbf{1} \arrow[r, "y", bend left]         & \textbf{2} \arrow[r, "X", dotted, bend left]            & \textbf{2} \arrow[r, "Y", bend left] & \textbf{1} \\ 
		\textbf{2} \arrow[r, "x", bend left] & \textbf{2} \arrow[r, "y", bend left]         & \textbf{3} \arrow[r, "X", dotted, bend left]            & \textbf{3} \arrow[r, "Y", bend left] & \textbf{2}
		\end{tikzcd}
	\end{center}

\pause
	Así terminamos de completar la tabla.
	
	\begin{table}[]
		\begin{tabular}{|l|l|l|l|l|}
			\hline
			Cosets     & x          & X          & y          & Y          \\ \hline
			\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
			\textbf{2} & \color{verde}\textbf{2} & \color{verde}\textbf{2} & \textbf{3} & \textbf{1} \\ \hline
			\textbf{3} & \color{verde}\textbf{3} & \color{verde}\textbf{3} & \textbf{1} & \textbf{2} \\ \hline
		\end{tabular}
	\end{table}
	\pause
	¿El procedimiento terminó? 
	\pause
	Deberíamos verificar que escanea correctamente a todas las relaciones.
	\pause
	Una vez verificado esto obtenemos que el índice del subgrupo $H$ en $G$ resulta ser la cantidad de cosets que nos terminaron quedando, en este caso exactamente $3$.
\end{frame}


\begin{frame}[fragile]{Método de las relaciones.}
	
	La estrategia para enumerar cosets que vamos a seguir se llama el \alert{ método de las relaciones}.
	\pause
	
	
	
	El siguiente grafo nos va a orientar con los procesos que vamos a definir:
	\medskip
	%Hacer un tikzcd con el grafo con palabras así como aparecía en el manual.
	
	% Define block styles
	\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
	text width=10em, text centered, rounded corners, minimum height=1.5em]
	\tikzstyle{line} = [draw, -latex']
	
	\begin{tikzpicture}[node distance = 1.5cm, auto]
	% Place nodes
	\node [block] (cosetenum) {\textsc{CosetEnumeration}};
	\node [block, below of=cosetenum] (scanfill) {\scanfill};
	\node [block, below of=scanfill] (def) {\definir};
	\node [block, right of=def, node distance=5cm] (coincidence) {\coin};
	\node [block, left of=def, node distance=5cm] (ded) {\ded};
	
	\node [block, below of=coincidence] (rep) {\rep};
	\node [block, left of=rep, node distance=5cm] (merge) {\mer};
	% Draw edges
	\path [line] (cosetenum) -- (scanfill);
	\path [line] (scanfill) -- (def);
	\path [line] (scanfill) -- (ded);
	\path [line] (scanfill) -- (coincidence);
	\path [line] (coincidence) -- (merge);
	\path [line] (coincidence) -- (rep);
	\end{tikzpicture}
\end{frame}


\begin{frame}[fragile]{Algoritmo de escanear y completar.}
Primero definimos un algoritmo que dado un coset y una palabra recorre hasta donde puede y nos devuelve hasta donde llegó y qué es lo que le quedó por leer de la palabra.
\begin{codebox}
	\Procname{$\proc{Recorrer}(\Co : \text{Tabla de Cosets}, i : \text{Coset}, w : A^*) :  (j : \text{Coset}, \ v : A^*)$}
	\li \textbf{Match} $w$, 
	\Do 
	\li $ | \  \ \emptyset = (i, \emptyset)$ 
	\li $ | \ \  xu =$ \textbf{si} $\edeff(\Co, i,x)$ \textbf{entonces}  $\recorrer(\Co, i^x, u) $ \textbf{sino} $(i, w)$
	\End
\end{codebox}
\pause

Donde la función \edeff($\Co, i, x$) nos devuelve \textsc{true} si $i^x$ está definido y \textsc{false} si no lo está.
\medskip
\pause	

\end{frame}

\begin{frame}[fragile]{Algoritmo de Scan and Fill.}
	
	La función \scanfill \  nos va a ir definiendo cosets a medida que escaneamos con el propósito de terminar de escanear sin inconvenientes a la relación.	
	
	\begin{codebox}
		\Procname{
			$\proc{ScanAndFill}(\Co : \text{Tabla de cosets}, \ i : \text{coset}, \ r : R) : \ \  (\Co' : \text{Tabla de cosets})$}
		\li \textbf{Sea} ($j$,$w_1$) := \recorrer$(\Co, i, w)$ en
		\Do 
		\li			\textbf{Sea} ($\textbf{k}$, $w_2$) :=  \recorrer$(\Co,i, w_1^{-1})$ en
		\Do 
		\li 		\textbf{Match} $w_2^{-1}$, 
		\Do 
		\li $\|$ \ $\emptyset$ = \ \textbf{Si }\ $j = \textbf{k}$ \  \textbf{entonces} \  \Co \ \ \textbf{sino} \coin \ $(\Co, j, \textbf{k})$
		\li $\|$ \ $x$ = \ded \ $(\Co, j, \textbf{k}, x)$
		\li $\|$ \ $xw'$ = \scanfill \  (\definir \ $(\Co, j, x), i, w)$ 
		\End
	\end{codebox}
\end{frame}


\begin{frame}[fragile]{Algoritmo para definir.}
	
Este algoritmo nos define $i^x$ como un nuevo coset aumentando la cantidad de cosets definidos hasta el momento en uno. 
\pause	
\begin{codebox}
	\Procname{$\proc{Definir} (\Co : \text{Tabla de Cosets}, i : \In , x : A) : ( \Co' : \text{Tabla de Cosets})  $}
	\li $n = n+1$
	\li $p(n+1) = n+1$
	\li $i^x = n+1,  {(n+1)}^X = i $
	\li \Comment $\tau(n+1) = \tau(i) x$
\end{codebox}
\pause
	
Todas las propiedades siguen valiendo después de ejecutar esta rutina.	
%Agregar las propiedades al costadito para recordarlas y comentar por arriba porqué siguen valiendo.	.
\end{frame}

\begin{frame}[fragile]{Cosets vivos.}
	Cuando enumeramos los cosets muchas veces sucederá que enumeraremos de manera distinta a un mismo coset. 
	Esto es que para ciertos $i \neq j \in \In$ tendremos que $H \tau (i) = H \tau (j)$.
	\pause
	Para distinguirlos introduciremos una función decreciente de los cosets en sí mismo $p: \In \to \In$.
	
	\pause
	\begin{alertblock}{Definición.}
		Los \emph{cosets vivos} son el subconjunto de cosets enumerados dados por $\Omega = \{ i \in \In  \ | \ p(i) = i \}$.
	\end{alertblock}
	
\end{frame}

\begin{frame}[fragile]{Rep.}
	
	Este algoritmo nos busca un representante de la clase de equivalencia de $i$, un coset de una tabla $\Co$, con respecto a la $G-$equivalencia generada por $p$.
	
	\pause
	
	\begin{codebox}
		\Procname{$\proc{rep}( \Co : \text{Tabla de cosets}, i : \text{coset}) : (\textbf{k} : \text{coset})  $}
		\li \textbf{Si} $p(i) = i$ \textbf{entonces} $i$ \textbf{sino} $\rep(\Co, p(i))$
	\end{codebox}
\pause

En particular como $p$ es una función decreciente sobre un subconjunto de naturales tenemos que si la aplicamos consecutivamente en algún momento tiene un punto fijo.
\end{frame}

\begin{frame}[fragile]{Merge.}
	Este algoritmo une dos clases de equivalencia cambiándole el valor de $p$ del representante de una clase a que valga el de la otra clase y nos devuelve una lista con todos los cosets a los cuales les cambiamos el representante.
	\pause
	\begin{codebox}
		\Procname{$\proc{merge}( \Co : \text{Tabla de cosets}, i : \text{coset}, j : \text{coset}) : (\Co' : \text{Tabla de cosets}, q : \text{lista de cosets})$}
		\li \textbf{Sean} $\textbf{k} = \rep(i), \textbf{l} = \rep(j)$
		\li \textbf{Si} $ \textbf{k} \neq \textbf{l}$ \textbf{entonces} 
		\Do 
		\li \textbf{Sean} $\mu = \max(\textbf{k}, \textbf{l}), \nu = \min(\textbf{k}, \textbf{l})$
		\li $p(\mu) = \nu, q = [\mu]$
	\end{codebox}
		
\end{frame}

\begin{frame}[fragile]{$G$-equivalencias.}
	Sabemos que al finalizar el algoritmo nos queda la acción sobre los cosets $G/H$ si nos restringimos a $\Omega$ pero ¿qué sucede en el medio?
	\pause
	
	
	\begin{alertblock}{Definición}
		Una \alert{G-equivalencia} es una relación de equivalencia sobre un conjunto $X$ con una acción parcial de $G$ que aparte satisface la siguiente propiedad.
		Si $x \sim y$ luego para todo $g \in G$  vale que $xg \sim yg$ siempre y cuando $xg$ e $yg$ estén definidas.
	\end{alertblock}
	\pause
	
	
	
	Así como tenemos relaciones de equivalencias generadas a partir de algún subconjunto $S \subseteq X \times X$ podemos considerar la menor $G$ equivalencia generada a partir de $S$.
	
	
	
	\pause
	\begin{columns}
		\begin{column}{0.6\textwidth}
			Cumple la siguiente propiedad universal.
			Si $\equiv$ es la menor $G$-equivalencia que contiene a $S$ y $\sim$ es otra $G$ equivalencia que contiene a $S$ entonces:
		\end{column}
		\pause
		\begin{column}{0.4\textwidth}
			\begin{center}
				{\large \begin{tikzcd}
					{X} \arrow[d, "\pi_S"', two heads] \arrow[r, "\pi", two heads] & {X / \sim} \\
					{ X  / \sim_S} \arrow[ru, "\exists \ol{ \pi_S}"', dashed]                       &                       
				\end{tikzcd}}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{$G$-equivalencias en nuestro contexto.}
	En nuestro caso consideramos que estamos en algún momento de nuestro algoritmo entonces:
	\pause
	\begin{itemize}
		\item El conjunto $X = \In$ los cosets definidos.
		\pause
		\item La relación $\sim$ es la generada a partir de $p$.
		\pause
		\item La acción parcial de $G$ justamente es la multiplicación a derecha de los cosets.
	\end{itemize}

\pause

Con esta notación vemos que $\In /\sim \ \simeq \ \Omega$.
\end{frame}

\begin{frame}[fragile]{Coincidencia.}

	Primero unas funciones auxiliares,
	\pause
	\begin{codebox}\Procname{$\proc{procesarLetra}(\Co : \text{Tabla de cosets}, i : \In, x : A ) : (\Co' : \text{Tabla de cosets}, q: \text{lista de cosets})$}
		\li \textbf{Si} \edeff($\Co, i, x$)
		%No sé si poner una función nueva o dejar esto así, en cierta manera es una auxiliar bastante evidente cómo es su pinta. 
		\Do 
		\li \textbf{Sea} $\textbf{l} = \textbf{k}^x, \mu = \rep(\textbf{k}), \nu = \rep(\textbf{l})$
		\li \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces} \mer($\Co', \mu^x, \nu$)
		\li \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces} \mer($\Co', \nu^X, \mu$)
		\li \textbf{Sino} $(\definir(\Co, \mu,x), [])$
	\end{codebox}
	\pause
	%Podemos extender esta función para que tome una lista de letras.
	\begin{codebox}\Procname{$\proc{coincidenciaLista}(\Co : \text{tabla de cosets}, q : \text{lista cosets}) : (\Co' : \text{tabla de cosets} )$}
		\li \textbf{Match} $(\Co, q)$,
		\Do
		\li $(\Co, []) = \Co$
		\li $(\Co, i::q) = \proc{coincidenceLista}(\Co'', q ++ q')$ 
		\Do 
		\li \textbf{Donde} $(\Co'', q') = \proc{procesarLetras} (\Co, i , A)$
		\li 
	\end{codebox}
	\pause
\end{frame}

\begin{frame}[fragile]{Algoritmo de \coin}
	Finalmente podemos definir \coin.
	\pause
	\begin{alertblock}{Idea del algoritmo.}
		Nos armamos la $G$-equivalencia generada a partir de $\sim$ y del par $(i, j)$.
	\end{alertblock}
	\pause
	\begin{codebox}
		\Procname{$\proc{coincidencia}(\Co : \text{Tabla de cosets}, i : \text{coset}, j : \text{coset}): ( \Co' : \text{Tabla de cosets} )$}
		\li \textbf{Sea} ($\Co', q$) = \mer($\Co, i$, $j$, $[]$), 
		\Do 
		%\li \textbf{Sea} $\textbf{k} = q[0]$ ,
		%%\li \edeff($ i, \textbf{k}$)
		%\li \textbf{Si} \edeff($\Co', \textbf{k}, x$) para $x \in A$,
		%%No sé si poner una función nueva o dejar esto así, en cierta manera es una auxiliar bastante evidente cómo es su pinta. 
		%\Do 
		%\li \textbf{Sea} $\textbf{l} = \textbf{k}^x, \mu = \rep(\textbf{k}), \nu = \rep(\textbf{l})$
		%\li \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces} \mer($\Co', \mu^x, \nu, q$)
		%\li \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces} \mer($\Co', \nu^X, \mu, q$)
		%\li \textbf{Sino} $\mu^x = \nu$, $\nu^X = \mu$ 
		\li  Sea $(\Co'', q')$ =  \proc{procesarLetras} ($\Co, i,  A$) 
		\Do 
		\li $\Co'  = $\proc{coincidenciaLista} {$ (\Co'', q')$}.
		
	\end{codebox}
\end{frame}

\begin{frame}[fragile]{Correctitud del algoritmo de coincidencia (1/3).}
	%Idea detallada de la demo. Explicarlo como lo de la $G$-equivalencia.
	Sea $\equiv$ la $G$-equivalencia generada a partir de la relación $\sim$ dada por $p$ y del par $(i, j)$.
	\pause
	Llamemos $\sim_F$ la relación que nos queda al terminar de hacer \coin.
	Esto es que $\textbf{k} \sim_F \textbf{l}$ si y solo sí al terminar el algoritmo $\rep (\textbf{k}) = \rep(\textbf{l})$ donde en este caso el representante lo estamos mirando respecto a esta nueva relación de equivalencia.
	\pause
	
	\begin{alertblock}{Lema}
		Si existen $\textbf{k}, \textbf{l} \in [1,\dots,n], x \in A$ tales que $\textbf{k}^x = \textbf{l}$ antes de comenzar el algoritmo entonces al terminarlo vale que $\rep(\textbf{k})^x = \rep(\textbf{l}).$
	\end{alertblock}
	\pause
	\textbf{Demostración.} 
	\pause
	Solo nos interesa los casos que modificamos el valor de $p'$. 
	Tomemos $\mu = \rep(\textbf{k}) $ y $\nu = \rep(\textbf{l})$.
	\pause
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{enumerate}
				\item Sea $\mu^x = \textbf{l}$. 
				Como $\rep (\textbf{l}) = \rep (\nu)$ por lo tanto $\rep(\textbf{k})^x = \mu^x = \textbf{l} $ y $\textbf{l} \sim \nu $ por lo que $ \rep(\textbf{l}) = \rep (\textbf{l})$.
				\item Similar al caso anterior tomando $\nu^{x^{-1}} = \textbf{k}$.
				\item En particular $\rep(\textbf{k})^x = \rep(\textbf{l}).$
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}  %%<--- here
			\begin{enumerate}
				\item  \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces}
				
				 \mer($\Co', \mu^x, \nu, q$) 
				\item  \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces}
				
				  \mer($\Co', \nu^X, \mu, q$)
				\item \textbf{Sino} $\mu^x = \nu$, $\nu^X = \mu$ 
			\end{enumerate}
		\end{column}
	\end{columns}
\end{frame}


\begin{frame}[fragile]{Correctitud del algoritmo de coincidencia (2/3).}
	\begin{alertblock}{Teorema.}
		Al terminar del correr el algoritmo \coin($i, j$) obtenemos la siguiente igualdad para todo $\textbf{k}, \textbf{l} \in [1,\dots,n]$,
		\begin{equation*}
			\textbf{k} \sim_F \textbf{l} \iff \textbf{k} \equiv \textbf{l}.
		\end{equation*}
	\end{alertblock}
	\pause 
	
	\textbf{Demostración.} $(\Rightarrow)$
	\pause
	Ni bien comienza el algoritmo sabemos que vale esta implicación porque justamente $\equiv$ es la $G$-congruencia generada a partir de $\sim$ y del par $(i, j)$.
	\pause
	Los casos que llamamos a \mer \ son los casos que podría modificarse la relación $\sim$.
	El primer \mer \ agrega al par $(i, j)$ a la relación $\sim$ y sabemos que este par está por definición en $\equiv$.
	\pause
	
	
	En los otros llamados de \mer \ si tomamos $\mu = \rep(\textbf{k}) $ y $\nu = \rep(\textbf{l})$.
	\medskip
	\pause
	\begin{columns}
		\begin{column}{0.1\textwidth}
			
		\end{column}
		\begin{column}{0.6\textwidth}
			\begin{center}
				{ Tenemos $\textbf{k}^x = \textbf{l}$ tal que podemos suponer inductivamente que $\textbf{k} \sim \mu$ y que $\textbf{l} \sim \nu $.
				Si estamos en el caso \textbf{1} entonces está definido $\mu^x \sim_F \nu$ y como es una $G$-equivalencia obtenemos que $\mu^x \equiv \textbf{k}^x \equiv \textbf{l} \equiv \nu$. 
				Análogamente el caso \textbf{2}.}
			\end{center} 	
		\end{column}
		\begin{column}{0.3\textwidth}
			{\small \begin{enumerate}
				\item  \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces}
				
				\mer($\Co', \mu^x, \nu, q$) 
				\item  \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces}
				
				\mer($\Co', \nu^X, \mu, q$)
			\end{enumerate}}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Correctitud del algoritmo de coincidencia (3/3).}
	\textbf{Demostración.} $(\Leftarrow)$
	\pause
	\medskip
	\begin{columns}
		\begin{column}{0.7\textwidth}
			Usemos que $\equiv$ es la menor $G$-equivalencia que contiene a $\sim$ y al par $(i, j)$. 
			Veamos que $\sim_F$ es una $G$-equivalencia.
			\pause
			
			
			Para eso partamos de $\textbf{k} \sim_F \textbf{l}$ y veamos que si $x \in A$ es tal que $\textbf{k}^x$ y $\textbf{l}^x$ estén ambas definidas entonces $\textbf{k}^x \sim_F \textbf{l}^x$.
			\pause
			Esto es una consecuencia del lema anterior.
		\end{column}
		\begin{column}{0.3\textwidth}
			\begin{tikzcd}
			{[1 \dots n]} \arrow[d, "\pi"', two heads] \arrow[r, "\pi_F", two heads] & {[1 \dots n] / \sim_F} \\
			{[1 \dots n] / \equiv} \arrow[ru, "\ol{ \pi}"', dashed]                       &                       
			\end{tikzcd}
			
			Donde $\ol {\pi}$ es sobreyectiva. 
		\end{column}
	\end{columns}
\qedsymbol
\end{frame}

\begin{frame}[fragile]{Algoritmo de enumeración de cosets.}

La idea es hacer \scanfill \ en todos los generadores de $H$ sobre el coset $1$ y después sobre todos los cosets vivos y todas las relaciones (ambos conjuntos finitos) hasta que escanee correctamente.


\begin{codebox}
	\Procname{
		$\proc{CosetEnumeration}(G : \text{Grupo}, X : \text{Conjunto}, \ R : {\cal P}(A^{*}), \ Y : {\cal P}{(A^*)} ) : \ \  (\Co : \text{Tabla de cosets})$
	}
	\li  \Comment Inicializamos la tabla de cosets para nuestra presentación de $G$.
	\li $n=1, p[1]=1$,
	\li \scanfill$(\Co, 1, y)$ para $y \in Y$ 
	\li \scanfill$(\Co', A)$ para todo $i \in \Omega, x \in A$
	\End
\end{codebox}
%Acá hay un leve abuso de notación porque en realidad estamos llamando a \scanfill sobre tabla de cosets distintas...
\pause

\end{frame}





\begin{frame}[fragile]{Cuándo termina el procedimiento.}
	¿En qué caso termina el algoritmo de enumeración de cosets?
	\pause
	Termina si el subgrupo que tomamos $H$ es tal que $[G:H] < \infty$.
	\pause

	Consideremos el (posiblemente infinito) conjunto $\ol \Omega$ de los cosets que no son eliminados por ningún llamado de \coin.

	\pause
	
	\textbf{Propiedad 5.} El conjunto $\ol \Omega$ es tal que:
	\begin{enumerate}
		\item Para cada $i \in \overline \Omega$ y para cada $x \in A$ en algún momento $i^x$ va a estar definido;
		\item Para cada $w \in Y$ en algún momento llamamos a \scan($\textbf{1},w$);
		\item Para cada $i \in \ol \Omega$ y para cada $w \in R$ en algún momento llamamos a \scan$(i, w)$.
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Continuación.}
	\begin{alertblock}{Teorema}
		Si las propiedades 1 a 5 se mantienen durante el algoritmo de enumeración de cosets de $G$ con respecto al subgrupo $H$ y $[G:H] < \infty$ entonces el algoritmo eventualmente termina.
	\end{alertblock}
	\pause
	
	\textbf{Demostración.} 
	Primero veamos el caso que $\ol \Omega$ es finito.
	\begin{itemize}
		\pause
		\item Usamos la \textbf{P5} para ver que en algún momento $i^x$ queda definido para todo $i \in \ol\Omega, x \in A$.
		\pause 
		Podemos tomar el momento para que todo estos cosets estén estabilizados.
		\pause
		En ese momento tendríamos que $\Omega = \ol \Omega$ y nuestra tabla está completa y así nuestro algoritmo termina.
	\end{itemize}
	\pause
	Veamos el caso que $\ol \Omega$ es infinito.
	\begin{itemize}
		\pause
		\item Como vale \textbf{P5} estamos en condiciones de usar el teorema anterior de manera que el índice de $H$ resulta ser infinito.
		Contradicción.
		\qedsymbol
	\end{itemize}
		
	
		%Agregar la propiedad y la proposición anterior al costadito.
	
\end{frame}

\end{document}