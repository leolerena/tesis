\documentclass[aspectratio=169, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}
\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}
\usepackage{hyperref}
\usepackage{eufrak}
\usepackage{tikz-cd}
\usepackage{tcolorbox}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem
	\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}

\setbeamercolor{background canvas}{bg=white}
\usepackage{multicol}
\usepackage{chronology}
%%%%%%%%%%%%%%%%%%%%% ENUMERAR CON COSAS QUE NO SEAN SOLO NÚMEROS %%%%%%%%%%
%\usepackage[shortlabels]{enumitem}
%\setlist[enumerate]{font=\bfseries}

\usepackage{booktabs}
%\usepackage[scale=2]{ccicons}

\usepackage{clrscode3e}

%%%%%%%% ALGORITMOS %%%%%%%%
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}  % "noend" es para no mostrar los endfor, endif

% PARA PODER HACER EL FLOW CHART
\usetikzlibrary{shapes,arrows}

\usepackage{pgfplots}
%\usepgfplotslibrary{dateplot}
\colorlet{verde}{green!50!black}
\definecolor{amber}{rgb}{1.0, 0.49, 0.0}
\setbeamercolor{progress bar}{fg=amber,bg=alerted text.fg!50!black!10}

\makeatletter
\setlength{\metropolis@titleseparator@linewidth}{2pt}
\setlength{\metropolis@progressonsectionpage@linewidth}{2pt}
\setlength{\metropolis@progressinheadfoot@linewidth}{2pt}
\makeatother

\definecolor{ultramarine}{RGB}{81, 131, 232} 
\setbeamercolor{frametitle}{bg= ultramarine}

\usepackage{framed}
\definecolor{shadecolor}{gray}{0.9}

\renewcommand\qedsymbol{\textcolor{orange}{$\blacksquare$}}

\usepackage[font={footnotesize}]{caption}

% Para agregar columnas.
\usepackage{graphicx}
\usepackage{adjustbox}


\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}
\newcommand{\fg}{finitamente generado }
\newcommand{\fp}{finitamente presentado }
\newcommand{\rep}{\textsc{rep}}
\newcommand{\coin}{\textsc{coincidencia}}
\newcommand{\mer}{\textsc{merge}}
\newcommand{\edeff}{\textsc{estáDefinido}}
\newcommand{\scan}{\textsc{scan}}
\newcommand{\definir}{\textsc{definir}}
\newcommand{\scanfill}{\textsc{scanandfill}}
\newcommand{\ded}{\textsc{deducir}}
\newcommand{\recorrer}{\textsc{recorrer}}
\newcommand{\In}{[1 \dots n]}
\newcommand{\ol}{\overline}
\newcommand{\Co}{{\cal{C}}}



\title{Algoritmo de enumeración de cosets.}
\subtitle{Final de teoría de grupos.}
\date{\today}
\author{Leopoldo Lerena}
\institute{Universidad de Buenos Aires}
% \titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\begin{document}
\maketitle

\begin{frame}[fragile]{Introducción.}

El algoritmo de enumeración de cosets nos permite responder, en algunos casos, las siguientes preguntas elementales de un grupo $G$ conociendo una presentación suya.

\begin{itemize}
	\item ¿Cuál es su orden?
	\pause
	\item ¿Cuál es 	el índice de un subgrupo $H$?
	\pause
	\item ¿Cómo es su grafo de Cayley?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Algoritmos en teoría de grupos.}
	Muchos preguntas elementales de la teoría de grupos tales como:
	\begin{itemize}
		\item Dada una palabra en los generadores, ¿es igual a la identidad del grupo?
		\pause
		\item ¿Es un grupo finito?
		\pause
		\item Más aún, ¿es el grupo trivial?
	\end{itemize}
	\pause
	No son \textit{decidibles}. 
	Esto es que no existe un algoritmo que nos pueda responder estas preguntas para cualquier grupo que le preguntemos.
	\medskip
	
	\pause
	
	
	Nos tenemos que conformar con que existan procedimientos que son \textit{semidecidibles}. 
	Esto es que si resulta que este grupo cumple estas propiedades podremos probarlo
	que este procedimiento da la respuesta correcta.
\end{frame}

\begin{frame}[fragile]{Descripción del algoritmo.}
	El procedimiento de enumeración de cosets requiere los siguientes parámetros para la entrada:
	\begin{itemize}
		\item Un grupo $G$ \fp;
		\pause
		\item Una presentación finita de este grupo $\langle X | R \rangle$;
		\pause
		\item Un subgrupo $H \le G$  \fg con generadores $Y$ visto como palabras en $A = X \cup X^{-1}$.
	\end{itemize}
	\pause
	\medskip
	
	En el caso que el procedimiento termine nos va a devolver lo siguiente:
	\begin{itemize}
		\item El índice del subgrupo $H$ en $G$.
		\pause
		\item La representación de $G$ por permutaciones actuando a derecha por multiplicación sobre los cosets a derecha de $H$.
		\pause 
	\end{itemize}  
\end{frame}

%\begin{frame}[fragile]{Un poco de historia.}
%	El primer algoritmo de esta familia fue construido por Todd--Coxeter en el paper ""
%	\alert{Agregar imagen del paper}
%	con la idea de poder hacer manualmente este conteo de  
%\end{frame}

\begin{frame}[fragile]{Ejemplo (1/4)}
	\section{Ejemplo a mano del procedimiento.}
	Partamos del grupo \fp $G = \langle x, y | x^2, y^3, xyXY \rangle$.
	\pause
	Tomemos como subgrupo $H = \langle x \rangle$.
	\pause
	El algoritmo entonces lo que nos debería devolver es $|G:H| = 3$.
	\pause
	\medskip
	
	
	Empezamos denotando con \textbf{1} al coset trivial correspondiente a $H$ en $G/H$.
	\pause 
	Como $x \in H$ entonces sabemos que $Hx = H$, denotaremos por $\textbf{1}^x = \textbf{1}$ a la multiplicación de $\textbf{1}$ por $x$.
	Similarmente $\textbf{1}^{X} = \textbf{1}$.
	\pause
	Por otro lado denotemos con \textbf{2} al coset $\textbf{1}^y$ y denotaremos por \textbf{3} al coset $\textbf{1}^{Y}$.
	\pause
	
	Por ahora esto es lo que sabemos de la acción de $G$ sobre los cosets.
	\begin{table}[]
		\begin{tabular}{|l|l|l|l|l|}
			\hline
			Coset     & x          & X          & y          & Y          \\ \hline
			\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
			\textbf{2} &            &            &            &  \textbf{1}          \\ \hline
			\textbf{3} &            &            &     \textbf{1}       &            \\ \hline
		\end{tabular}
	\end{table}
\end{frame}

\begin{frame}[fragile]{Ejemplo (2/4).}
% ¿Qué podemos hacer?
\pause
Sabemos que todo coset $\textbf{i}$ es tal que $\textbf{i}^r = \textbf{i}$ para todo $r \in R$.
\pause

Vamos a introducir un proceso que se llama \textit{escanear las relaciones}.

\pause
Por ejemplo tomemos $r = y^3$ y escaneamos a $\textbf{1}$.


\begin{table}[]
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		Coset     & x          & X          & y          & Y          \\ \hline
		\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
		\textbf{2} &            &            &            &  \textbf{1}          \\ \hline
		\textbf{3} &            &            &     \textbf{1}       &            \\ \hline
	\end{tabular}
\end{table}
\pause

Tenemos que $\textbf{1}^y = \textbf{2}$ por como definimos al coset $\textbf{2}$. 
Por otro lado tenemos que $\textbf{1}^{y^2} = \textbf{2}^y$ todavía no está definido.
\pause


Como $r^{-1} = 1$ visto como elemento en $G$ si escanemos ahora viendo esta relación tenemos que $\textbf{1}^{Y} = \textbf{3}$ porque así lo definimos y por otro lado que $\textbf{3}^{Y}$ no está definido.
\pause

\end{frame}

\begin{frame}[fragile]{Ejemplo (3/4)}
	De lo anterior podemos \textit{deducir} que $\textbf{2}^y = \textbf{3}$.
	
	\medskip
	\begin{center}
		\begin{tikzcd}
		\textbf{1} \arrow[r, "y", bend left] & \textbf{2} \arrow[r, "y", dotted, bend left] & \textbf{3} \arrow[r, "y", bend left] & \textbf{1}
		\end{tikzcd}
	\end{center}
	\pause
	
	De esta manera nuestra tabla ahora tiene la siguiente pinta.
	

	
	
	\begin{table}[]
		\begin{tabular}{|l|l|l|l|l|}
			\hline
			Cosets     & x          & X          & y          & Y          \\ \hline
			\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
			\textbf{2} &            &            & \color{verde}\textbf{3} &     \textbf{1}       \\ \hline
			{\textbf{3}} &            &            &   \textbf{1}         & \color{verde}\textbf{2} \\ \hline
		\end{tabular}
	\end{table}
	
	
\end{frame}

\begin{frame}[fragile]{Ejemplo (4/4)}
	Cuando escaneamos la relación $xyXY$ para los cosets \textbf{1} y \textbf{2} 
	llegamos a las siguientes deducciones 
	
	\begin{center}
		\begin{tikzcd}
		\textbf{1} \arrow[r, "x", bend left] & \textbf{1} \arrow[r, "y", bend left]         & \textbf{2} \arrow[r, "X", dotted, bend left]            & \textbf{2} \arrow[r, "Y", bend left] & \textbf{1} \\
		\textbf{2} \arrow[r, "x", bend left] & \textbf{2} \arrow[r, "y", bend left]         & \textbf{3} \arrow[r, "X", dotted, bend left]            & \textbf{3} \arrow[r, "Y", bend left] & \textbf{2}
		\end{tikzcd}
	\end{center}

\pause
	Así terminamos de completar la tabla.
	
	\begin{table}[]
		\begin{tabular}{|l|l|l|l|l|}
			\hline
			Cosets     & x          & X          & y          & Y          \\ \hline
			\textbf{1} & \textbf{1} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
			\textbf{2} & \color{verde}\textbf{2} & \color{verde}\textbf{2} & \textbf{3} & \textbf{1} \\ \hline
			\textbf{3} & \color{verde}\textbf{3} & \color{verde}\textbf{3} & \textbf{1} & \textbf{2} \\ \hline
		\end{tabular}
	\end{table}
	
	El procedimiento terminó y obtenemos que el índice del subgrupo $H$ en $G$ resulta ser la cantidad de cosets que nos terminaron quedando, en este caso exactamente $3$.
\end{frame}

\begin{frame}[fragile]{Tabla de cosets.}
	Sea $G = \langle X | R \rangle$ un grupo \fp y sea $A = X \cup X^{-1}$ sus generadores y sus inversos.
	\pause
	
	La tabla de cosets $\Co $ va a ser una tupla $(n, \tau, \chi, p)$ donde:
	\pause
	\begin{itemize}
		\item $n \in  \mathbb{N}$ es la cantidad de cosets que tenemos definidos, esto es el intervalo $\In$ va a representar a todos los cosets definidos;
		\pause
		\item $\tau : \In \to A^*$ es una función que a cada coset $\textbf{i}$ le asigna una palabra en los generadores tal que $\tau(\textbf{i})$ sea un representante de la clase de este coset.
		\pause
		\item $\chi: \In \times A \to \In$ una función parcial que (cuando está definida) tal que $\chi(\textbf{i}, x) = \textbf{j} \iff \textbf{i}^x = \textbf{j}$.
		\pause
		\item $p: [1 \dots n] \to [1 \dots n]$ una función tal que $p(\textbf{i}) \le \textbf{i}$ para todo $\textbf{i} \in [1\dots n]$.
	\end{itemize}
	
\end{frame}

\begin{frame}[fragile]{Cosets vivos.}
	Definimos los \emph{cosets vivos} como $\Omega = \{ \textbf{i} \in \In  \ | \ p(\textbf{i}) = \textbf{i} \}$.
	Muchas veces nos va suceder que dos valores $\textbf{i}, \textbf{j} \in \In$ se corresponden al mismo coset.
	El rol de $p$ es diferenciarnos qué elementos de $\In$ efectivamente se corresponden a distintos cosets.
	\pause
	\medskip
	
	
	
	La tabla está \emph{completa} si la restricción $\chi:\Omega \times A \to \In$ está definida para todos los pares $(\textbf{i}, x) \in \Omega \times A$. 
\end{frame}

\begin{frame}[fragile]{Propiedades de la tabla de cosets.}
	La tabla de cosets vamos a querer que mantenga ciertas propiedades a medida que corramos el algoritmo, esto vendría a ser el invariante de representación.
	\pause
	
	
	
	\begin{enumerate}
		\item $1 \in \Omega$ y $1^{\tau(\textbf{i})} = \textbf{i}$.
		\pause
		\item $\textbf{i}^x = \textbf{j} \iff \textbf{j}^{X} = \textbf{i}$.
		\pause
		\item Si $\textbf{i}^x = \textbf{j}$ entonces tenemos que $H \tau(\textbf{i}) x = H \tau(\textbf{j})$
		\pause
		\item Para todo $\textbf{i} \in \Omega$ tenemos que $1^{\tau(\textbf{i})}$ está definido y $1^{\tau(\textbf{i})} = \textbf{i}$.
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Método de las relaciones.}
	
	La estrategia para enumerar cosets que vamos a seguir se llama el \alert{ método de las relaciones}.
	\pause
	
	
	
	El siguiente grafo nos va a orientar con los procesos que vamos a definir:
	\medskip
	%Hacer un tikzcd con el grafo con palabras así como aparecía en el manual.
	
	% Define block styles
	\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
	text width=10em, text centered, rounded corners, minimum height=1.5em]
	\tikzstyle{line} = [draw, -latex']
	
	\begin{tikzpicture}[node distance = 1.5cm, auto]
	% Place nodes
	\node [block] (cosetenum) {\textsc{CosetEnumeration}};
	\node [block, below of=cosetenum] (scanfill) {\scanfill};
	\node [block, below of=scanfill] (def) {\definir};
	\node [block, right of=def, node distance=5cm] (coincidence) {\coin};
	\node [block, left of=def, node distance=5cm] (ded) {\ded};
	
	\node [block, below of=coincidence] (rep) {\rep};
	\node [block, left of=rep, node distance=5cm] (merge) {\mer};
	% Draw edges
	\path [line] (cosetenum) -- (scanfill);
	\path [line] (scanfill) -- (def);
	\path [line] (scanfill) -- (ded);
	\path [line] (scanfill) -- (coincidence);
	\path [line] (coincidence) -- (merge);
	\path [line] (coincidence) -- (rep);
	\end{tikzpicture}
\end{frame}


\begin{frame}[fragile]{Algoritmo de escanear y completar.}
Primero definimos un algoritmo que dado un coset y una palabra recorre hasta donde puede y nos devuelve hasta donde llegó y qué es lo que le quedó por leer de la palabra.
\begin{codebox}
	\Procname{$\proc{Recorrer}(\Co : \text{Tabla de Cosets}, \textbf{i} : \text{Coset}, w : A^*) :  (\textbf{j} : \text{Coset}, \ v : A^*)$}
	\li \textbf{Match} $w$, 
	\Do 
	\li $ | \  \ \emptyset = (\textbf{i}, \emptyset)$ 
	\li $ | \ \  xu =$ \textbf{si} $\edeff(\Co, \textbf{i},x)$ \textbf{entonces}  $\recorrer(\Co, \textbf{i}^x, u) $ \textbf{sino} $(\textbf{i}, w)$
	\End
\end{codebox}
\pause

Donde la función \edeff($\Co, \textbf{i}, x$) nos devuelve \textsc{true} si $\textbf{i}^x$ está definido y \textsc{false} si no lo está.
\medskip
\pause	

\end{frame}

\begin{frame}[fragile]{Algoritmo de Scan and Fill.}
	
	La función \scanfill \  nos va a ir definiendo cosets a medida que escaneamos con el propósito de terminar de escanear sin inconvenientes a la relación.	
	
	\begin{codebox}
		\Procname{
			$\proc{ScanAndFill}(\Co : \text{Tabla de cosets}, \ \textbf{i} : \text{coset}, \ r : R) : \ \  (\Co' : \text{Tabla de cosets})$}
		\li \textbf{Sea} ($\textbf{j}$,$w_1$) := \recorrer$(\Co, \textbf{i}, w)$ en
		\Do 
		\li			\textbf{Sea} ($\textbf{k}$, $w_2$) :=  \recorrer$(\Co,\textbf{i}, w_1^{-1})$ en
		\Do 
		\li 		\textbf{Match} $w_2^{-1}$, 
		\Do 
		\li $\|$ \ $\emptyset$ = \ \textbf{Si }\ $\textbf{j} = \textbf{k}$ \  \textbf{entonces} \  \Co \ \ \textbf{sino} \coin \ $(\Co, \textbf{j}, \textbf{k})$
		\li $\|$ \ $x$ = \ded \ $(\Co, \textbf{j}, \textbf{k}, x)$
		\li $\|$ \ $xw'$ = \scanfill \  (\definir \ $(\Co, \textbf{j}, x), \textbf{i}, w)$ 
		\End
	\end{codebox}
\end{frame}


\begin{frame}[fragile]{Algoritmo para definir.}
	
Este algoritmo nos define $\textbf{i}^x$ como un nuevo coset aumentando la cantidad de cosets definidos hasta el momento en uno. 
\pause	
\begin{codebox}
	\Procname{$\proc{Definir} (\Co : \text{Tabla de Cosets}, i : \In , x : A) : ( \Co' : \text{Tabla de Cosets})  $}
	\li $n = n+1$
	\li $p(n+1) = n+1$
	\li $i^x = n+1,  {(n+1)}^X = i $
	\li \Comment $\tau(n+1) = \tau(i) x$
\end{codebox}
\pause
	
Todas las propiedades siguen valiendo después de ejecutar esta rutina.	
%Agregar las propiedades al costadito para recordarlas y comentar por arriba porqué siguen valiendo.	.
\end{frame}

\begin{frame}[fragile]{Rep.}
	
	Este algoritmo nos busca un representante de la clase de equivalencia de $\textbf{i}$, un coset de una tabla $\Co$, con respecto a la $G-$equivalencia generada por $p$.
	
	\pause
	
	\begin{codebox}
		\Procname{$\proc{rep}( \Co : \text{Tabla de cosets}, \textbf{i} : \text{coset}) : (\textbf{k} : \text{coset})  $}
		\li \textbf{Si} $p(\textbf{i}) = \textbf{i}$ \textbf{entonces} $\textbf{i}$ \textbf{sino} $\rep(\Co, p(\textbf{i}))$
	\end{codebox}
\pause

En particular como $p$ es una función decreciente sobre un subconjunto de naturales tenemos que si la aplicamos consecutivamente en algún momento tiene un punto fijo.
\end{frame}

\begin{frame}[fragile]{Merge.}
	Este algoritmo une dos clases de equivalencia cambiándole el valor de $p$ del representante de una clase a que valga el de la otra clase y nos devuelve una lista con todos los cosets a los cuales les cambiamos el representante.
	\pause
	\begin{codebox}
		\Procname{$\proc{merge}( \Co : \text{Tabla de cosets}, \textbf{i} : \text{coset}, \textbf{j} : \text{coset}, q : \text{lista de Cosets}) : (\Co' : \text{Tabla de cosets})$}
		\li \textbf{Sean} $\textbf{k} = \rep(\textbf{i}), \textbf{l} = \rep(\textbf{j})$
		\li \textbf{Si} $ \textbf{k} \neq \textbf{l}$ \textbf{entonces} 
		\Do 
		\li \textbf{Sean} $\mu = \max(\textbf{k}, \textbf{l}), \nu = \min(\textbf{k}, \textbf{l})$
		\li $p(\mu) = \nu, q = q: \mu$
	\end{codebox}
		
\end{frame}

\begin{frame}[fragile]{$G$-equivalencias.}
	Sabemos que al finalizar el algoritmo nos queda la acción sobre los cosets $G/H$ si nos restringimos a $\Omega$ pero ¿qué sucede en el medio?
	\pause
	
	
	\begin{alertblock}{Definición}
		Una \alert{G-equivalencia} es una relación de equivalencia sobre un conjunto $X$ con una acción parcial de $G$ que aparte satisface la siguiente propiedad.
		Si $x \sim y$ luego para todo $g \in G$  vale que $xg \sim yg$ siempre y cuando $xg$ e $yg$ estén definidas.
	\end{alertblock}
	\pause
	
	
	
	Así como tenemos relaciones de equivalencias generadas a partir de algún subconjunto $S \subseteq X \times X$ podemos considerar la menor $G$ equivalencia generada a partir de $S$.
	
	
	
	\pause
	\begin{columns}
		\begin{column}{0.6\textwidth}
			Cumple la siguiente propiedad universal.
			Si $\equiv$ es la menor $G$-equivalencia que contiene a $S$ y $\sim$ es otra $G$ equivalencia que contiene a $S$ entonces:
		\end{column}
		\pause
		\begin{column}{0.4\textwidth}
			\begin{center}
				{\large \begin{tikzcd}
					{X} \arrow[d, "\pi_S"', two heads] \arrow[r, "\pi", two heads] & {X / \sim} \\
					{ X  / \sim_S} \arrow[ru, "\exists \ol{ \pi_S}"', dashed]                       &                       
				\end{tikzcd}}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{$G$-equivalencias en nuestro contexto.}
	En nuestro caso consideramos que estamos en algún momento de nuestro algoritmo entonces:
	\pause
	\begin{itemize}
		\item El conjunto $X = \In$ los cosets definidos.
		\pause
		\item La relación $\sim$ es la generada a partir de $p$.
		\pause
		\item La acción parcial de $G$ justamente es la multiplicación a derecha de los cosets.
	\end{itemize}

\pause

Con esta notación vemos que $\In /\sim \ \simeq \ \Omega$.
\end{frame}

\begin{frame}[fragile]{Coincidencia.}
	\textbf{Idea del algoritmo}:
	Nos armamos la $G$-equivalencia generada a partir de $\sim$ y del par $(\textbf{i}, \textbf{j})$.
	\pause
	Primero una función auxiliar,
	\begin{codebox}\Procname{$\proc{coincidenciaLista}(\Co : \text{tabla de cosets}, q : \text{lista cosets}) : (\Co' : \text{tabla de cosets} )$}
		\li \textbf{Match} $(\Co, q)$,
		\li $(\Co, []) = \Co$
		\li $(\Co, i::q) =$ 
		\Do 
		\li \textbf{Sea} $(\Co', q') = \proc{procesarLetras} (\Co, i , A)$
		\li \proc{coincidenceLista}$(\Co', q ++ q')$
	\end{codebox}
	\pause
	Y finalmente podemos definir \coin.
	\begin{codebox}
		\Procname{$\proc{coincidencia}(\Co : \text{Tabla de cosets}, \textbf{i} : \text{coset}, \textbf{j} : \text{coset}): ( \Co' : \text{Tabla de cosets} )$}
		\li \textbf{Sea} ($\Co', q$) = \mer($\Co, \textbf{i}$, $\textbf{j}$, $[]$), 
		\Do 
		%\li \textbf{Sea} $\textbf{k} = q[0]$ ,
		%%\li \edeff($ \textbf{i}, \textbf{k}$)
		%\li \textbf{Si} \edeff($\Co', \textbf{k}, x$) para $x \in A$,
		%%No sé si poner una función nueva o dejar esto así, en cierta manera es una auxiliar bastante evidente cómo es su pinta. 
		%\Do 
		%\li \textbf{Sea} $\textbf{l} = \textbf{k}^x, \mu = \rep(\textbf{k}), \nu = \rep(\textbf{l})$
		%\li \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces} \mer($\Co', \mu^x, \nu, q$)
		%\li \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces} \mer($\Co', \nu^X, \mu, q$)
 		%\li \textbf{Sino} $\mu^x = \nu$, $\nu^X = \mu$ 
 		\li  Sea $(\Co'', q')$ =  \proc{procesarLetras} ($\Co, i,  x$) para $x \in A$
 		\Do 
 		\li \proc{coincidenciaLista} {$ (\Co'', q)$}.
 		
	\end{codebox}
\end{frame}
\begin{frame}[fragile]{Correctitud del algoritmo de coincidencia (1/3).}
	%Idea detallada de la demo. Explicarlo como lo de la $G$-equivalencia.
	Sea $\equiv$ la $G$-equivalencia generada a partir de la relación $\sim$ dada por $p$ y del par $(\textbf{i}, \textbf{j})$.
	\pause
	Llamemos $\sim_F$ la relación que nos queda al terminar de hacer \coin.
	Esto es que $\textbf{k} \sim_F \textbf{l}$ si y solo sí al terminar el algoritmo $\rep (\textbf{k}) = \rep(\textbf{l})$ donde en este caso el representante lo estamos mirando respecto a esta nueva relación de equivalencia.
	\pause
	
	\begin{alertblock}{Lema}
		Si existen $\textbf{k}, \textbf{l} \in [1,\dots,n], x \in A$ tales que $\textbf{k}^x = \textbf{l}$ antes de comenzar el algoritmo entonces al terminarlo vale que $\rep(\textbf{k})^x = \rep(\textbf{l}).$
	\end{alertblock}
	\pause
	\textbf{Demostración.} 
	\pause
	Solo nos interesa los casos que modificamos el valor de $p'$. 
	Tomemos $\mu = \rep(\textbf{k}) $ y $\nu = \rep(\textbf{l})$.
	\pause
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{enumerate}
				\item Sea $\mu^x = \textbf{l}$. 
				Como $\rep (\textbf{l}) = \rep (\nu)$ por lo tanto $\rep(\textbf{k})^x = \mu^x = \textbf{l} $ y $\textbf{l} \sim \nu $ por lo que $ \rep(\textbf{l}) = \rep (\textbf{l})$.
				\item Similar al caso anterior tomando $\nu^{x^{-1}} = \textbf{k}$.
				\item En particular $\rep(\textbf{k})^x = \rep(\textbf{l}).$
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}  %%<--- here
			\begin{enumerate}
				\item  \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces}
				
				 \mer($\Co', \mu^x, \nu, q$) 
				\item  \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces}
				
				  \mer($\Co', \nu^X, \mu, q$)
				\item \textbf{Sino} $\mu^x = \nu$, $\nu^X = \mu$ 
			\end{enumerate}
		\end{column}
	\end{columns}
\end{frame}


\begin{frame}[fragile]{Correctitud del algoritmo de coincidencia (2/3).}
	\begin{alertblock}{Teorema.}
		Al terminar del correr el algoritmo \coin($\textbf{i}, \textbf{j}$) obtenemos la siguiente igualdad para todo $\textbf{k}, \textbf{l} \in [1,\dots,n]$,
		\begin{equation*}
			\textbf{k} \sim_F \textbf{l} \iff \textbf{k} \equiv \textbf{l}.
		\end{equation*}
	\end{alertblock}
	\pause 
	
	\textbf{Demostración.} $(\Rightarrow)$
	\pause
	Ni bien comienza el algoritmo sabemos que vale esta implicación porque justamente $\equiv$ es la $G$-congruencia generada a partir de $\sim$ y del par $(\textbf{i}, \textbf{j})$.
	\pause
	Los casos que llamamos a \mer \ son los casos que podría modificarse la relación $\sim$.
	El primer \mer \ agrega al par $(\textbf{i}, \textbf{j})$ a la relación $\sim$ y sabemos que este par está por definición en $\equiv$.
	\pause
	
	
	En los otros llamados de \mer \ si tomamos $\mu = \rep(\textbf{k}) $ y $\nu = \rep(\textbf{l})$.
	\medskip
	\pause
	\begin{columns}
		\begin{column}{0.1\textwidth}
			
		\end{column}
		\begin{column}{0.6\textwidth}
			\begin{center}
				{ Tenemos $\textbf{k}^x = \textbf{l}$ tal que podemos suponer inductivamente que $\textbf{k} \sim \mu$ y que $\textbf{l} \sim \nu $.
				Si estamos en el caso \textbf{1} entonces está definido $\mu^x \sim_F \nu$ y como es una $G$-equivalencia obtenemos que $\mu^x \equiv \textbf{k}^x \equiv \textbf{l} \equiv \nu$. 
				Análogamente el caso \textbf{2}.}
			\end{center} 	
		\end{column}
		\begin{column}{0.3\textwidth}
			{\small \begin{enumerate}
				\item  \textbf{Si} $\edeff(\Co', \mu, x)$ \textbf{entonces}
				
				\mer($\Co', \mu^x, \nu, q$) 
				\item  \textbf{Si} $\edeff(\Co', \nu, X)$  \textbf{entonces}
				
				\mer($\Co', \nu^X, \mu, q$)
			\end{enumerate}}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Correctitud del algoritmo de coincidencia (3/3).}
	\textbf{Demostración.} $(\Leftarrow)$
	\pause
	\medskip
	\begin{columns}
		\begin{column}{0.7\textwidth}
			Usemos que $\equiv$ es la menor $G$-equivalencia que contiene a $\sim$ y al par $(\textbf{i}, \textbf{j})$. 
			Veamos que $\sim_F$ es una $G$-equivalencia.
			\pause
			
			
			Para eso partamos de $\textbf{k} \sim_F \textbf{l}$ y veamos que si $x \in A$ es tal que $\textbf{k}^x$ y $\textbf{l}^x$ estén ambas definidas entonces $\textbf{k}^x \sim_F \textbf{l}^x$.
			\pause
			Esto es una consecuencia del lema anterior.
		\end{column}
		\begin{column}{0.3\textwidth}
			\begin{tikzcd}
			{[1 \dots n]} \arrow[d, "\pi"', two heads] \arrow[r, "\pi_F", two heads] & {[1 \dots n] / \sim_F} \\
			{[1 \dots n] / \equiv} \arrow[ru, "\ol{ \pi}"', dashed]                       &                       
			\end{tikzcd}
			
			Donde $\ol {\pi}$ es sobreyectiva. 
		\end{column}
	\end{columns}
\qedsymbol
\end{frame}

\begin{frame}[fragile]{Algoritmo de enumeración de cosets.}

La idea es hacer \scanfill \ en todos los generadores de $H$ sobre el coset $1$ y después sobre todos los cosets vivos y todas las relaciones (ambos conjuntos finitos) hasta que escanee correctamente.


\begin{codebox}
	\Procname{
		$\proc{CosetEnumeration}(G : \text{Grupo}, X : \text{Conjunto}, \ R : {\cal P}(A^{*}), \ Y : {\cal P}{(A^*)} ) : \ \  (\Co : \text{Tabla de cosets})$
	}
	\li  \Comment Inicializamos la tabla de cosets para nuestra presentación de $G$.
	\li $n=1, p[1]=1$,
	\li \scanfill$(\Co, 1, y)$ para $y \in Y$ 
	\li \scanfill$(\Co', A)$ para todo $\textbf{i} \in \Omega, x \in A$
	\End
\end{codebox}
%Acá hay un leve abuso de notación porque en realidad estamos llamando a \scanfill sobre tabla de cosets distintas...
\pause

\end{frame}


\begin{frame}[fragile]{Correctitud del algoritmo.}
Probemos que si el algoritmo termina entonces es correcto.
\pause
\begin{alertblock}{Teorema}
	Si valen las siguientes condiciones,
	\begin{itemize}
		\item Todas las propiedades \textbf{P1-P4} valen;
		\item La tabla de cosets está completa;
		\item \textbf{1} escanea correctamente para todo $w \in Y$;
		\item $\textbf{i}$ escanea correctamente para todo $r \in R$ y para todo $\textbf{i} \in \Omega$.
	\end{itemize}
	entonces $[G:H] = |\Omega|$ y para todo $x \in A$, $\varphi(x): \Omega \to \Omega$ definida por $\varphi(x)(i) = i^x$ es una permutación.
	A su vez podemos extender $\varphi$ para que esté definida sobre elementos $g \in G$ y sea morfismo de grupos y su acción sobre los cosets vivos coincida con la acción de $G$ en los cosets a derecha de $H$.
\end{alertblock}
\pause
\medskip
\end{frame}

\begin{frame}[fragile]{Demostración correctitud de enumeración de cosets.}
	\textbf{Demostración}.  
	\begin{columns}
		\begin{column}{0.3 \textwidth}
			\begin{enumerate}
				\item $1 \in \Omega$ y $1^{\tau(\textbf{i})} = \textbf{i}$.
				
				\item $\textbf{i}^x = \textbf{j} \iff \textbf{j}^{X} = \textbf{i}$.
				
				\item Si $\textbf{i}^x = \textbf{j}$ entonces tenemos que $H \tau(\textbf{i}) x = H \tau(\textbf{j})$
				
				\item Para todo $\textbf{i} \in \Omega$ tenemos que $1^{\tau(\textbf{i})}$ está definido y $1^{\tau(\textbf{i})} = \textbf{i}$.
				\pause
			\end{enumerate}
		\end{column}
		\begin{column}{0.7 \textwidth}
			Se extiende a un morfismo de grupos por la \textbf{P2} y porque escanea todas las relaciones.	
			\pause
			% Lo definimos sobre el monoide libre en un pcpio y con la P2 lo tenemos sobre el grupo libre.
			
			\medskip
			Sea $C$ el conjunto de los cosets a derecha de $H$ sobre $G$.
			Definimos la función 
			\[
			\ol \tau: \Omega \to C
			\]
			tal que $\ol \tau (\textbf{i}) = H \tau (\textbf{i})$.
			\pause
			Probemos que es una biyección.
			\pause
			\begin{itemize}
				\item Sobreyectiva. Usamos que la tabla está completa y que vale \textbf{P4}.
				\pause
				\item Inyectiva. Si $\ol \tau (\textbf{i}) = \ol \tau (\textbf{j})$ entonces $H \tau (\textbf{i}) \tau (\textbf{j})^{-1} = H$ y acá usamos que escanea correctamente a todos los generadores de $H$.
				\pause
			\end{itemize}
			Con esto concluimos que $[G:H] = |C| = |\Omega|$ y que la acción sobre $\Omega$ coincide con la acción sobre los cosets a derecha.	
			\qedsymbol
		\end{column}
	\end{columns}
\end{frame}


\begin{frame}[fragile]{Cuándo termina el procedimiento.}
	El algoritmo de enumeración de cosets termina si el subgrupo que tomamos $H$ es tal que $[G:H] < \infty$.
	\pause

	Consideremos el (posiblemente infinito) conjunto $\ol \Omega$ de los cosets que no son eliminados por ningún llamado de \coin.

	\pause
	
	\textbf{Propiedad 5.} El conjunto $\ol \Omega$ es tal que:
	\begin{enumerate}
		\item Para cada $\textbf{i} \in \overline \Omega$ y para cada $x \in A$ en algún momento $\textbf{i}^x$ va a estar definido;
		\item Para cada $w \in Y$ en algún momento llamamos a \scan($\textbf{1},w$);
		\item Para cada $\textbf{i} \in \ol \Omega$ y para cada $w \in R$ en algún momento llamamos a \scan$(\textbf{i}, w)$.
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Continuación.}
	\begin{alertblock}{Teorema}
		Si las propiedades 1 a 5 se mantienen durante el algoritmo de enumeración de cosets de $G$ con respecto al subgrupo $H$ y $[G:H] < \infty$ entonces el algoritmo eventualmente termina.
	\end{alertblock}
	\pause
	
	\textbf{Demostración.} 
	\begin{itemize}
		\item Primero veamos el caso que $\ol \Omega$ es finito.
		\pause
		\item Usamos la \textbf{P5} para ver que en algún momento $\textbf{i}^x$ queda definido para todo $\textbf{i} \in \ol\Omega, x \in A$.
		\pause 
		Podemos tomar el momento para que todo estos cosets estén estabilizados.
		\pause
		En ese momento tendríamos que $\Omega = \ol \Omega$ y nuestra tabla está completa y así nuestro algoritmo termina.
		\item Veamos el caso que $\ol \Omega$ es infinito.
		\pause
		\item Como vale la propiedad 5 estamos en condiciones de usar el teorema anterior \ref{} de manera que el índice de $H$ resulta ser infinito.
		Contradicción.
		\qedsymbol
		%Agregar la propiedad y la proposición anterior al costadito.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Ejemplo del algoritmo en $C_2 \ast C_3$ pt I.}
Primero podría probar que esto tiene que dar lo que tiene que dar usando el argumento topológico y después usar al algoritmo.
\end{frame}
\end{document}